# 补充知识点

1. arm常见指令
   1. 数据传输指令（Data Transfer Instructions）：
      - `MOV{cond}{S} Rd, Operand2`：将Operand2的值移动到寄存器Rd中。
      - `LDR{cond}{B}{T} Rd, [Rn{, #offset}]`：从内存中加载数据到寄存器Rd中。
      - `STR{cond}{B}{T} Rd, [Rn{, #offset}]`：将寄存器Rd的值存储到内存中。
   2. 算术和逻辑指令（Arithmetic and Logical Instructions）：
      - `ADD{cond}{S} Rd, Rn, Operand2`：将Rn和Operand2的值相加，结果存储在Rd中。
      - `SUB{cond}{S} Rd, Rn, Operand2`：将Rn的值减去Operand2，结果存储在Rd中。
      - `MUL{cond}{S} Rd, Rn, Rm`：将Rn和Rm的值相乘，结果存储在Rd中。
      - `AND{cond}{S} Rd, Rn, Operand2`：对Rn和Operand2进行逻辑与操作，结果存储在Rd中。
   3. 分支和跳转指令（Branch and Jump Instructions）：
      - `B{cond} label`：无条件跳转到指定的标签。
      - `BL{cond} label`：无条件跳转，并将下一条指令的地址保存到链接寄存器中。
      - `BEQ{cond} label`：如果前一次比较结果为相等，则跳转到指定标签。
      - `BNE{cond} label`：如果前一次比较结果为不相等，则跳转到指定标签。
   4. 条件指令（Conditional Instructions）：
      - `CMP{cond} Rn, Operand2`：比较Rn和Operand2的值，并设置条件码。
      - `TST{cond} Rn, Operand2`：测试Rn和Operand2的值，并设置条件码。
   5. 堆栈指令（Stack Instructions）：
      - `PUSH{cond} registers`：将指定的寄存器值压入堆栈。
      - `POP{cond} registers`：从堆栈中弹出值到指定的寄存器。

2. 需要tlb flush的场景总结：

   1. 进程切换：当操作系统进行进程切换时，当前运行的进程的页表会被切换为新进程的页表。在这种情况下，旧进程的虚拟地址与物理地址映射将变得无效，需要刷新TLB以更新为新进程的地址映射。

   2. 地址空间切换：当从用户空间切换到内核空间（如系统调用、中断处理等）或从内核空间切换回用户空间时，由于用户空间和内核空间拥有不同的地址空间，TLB中的虚拟地址到物理地址映射需要更新。

   3. 页面表更改：当操作系统更改页表的映射关系时，例如分配或释放内存、更改页面权限等，需要执行TLB刷新以确保新的映射关系在TLB中生效。

   4. 多核处理器：在多核处理器系统中，每个核心都有自己的TLB。如果一个核心更改了页表的映射关系，那么其他核心的TLB中的旧映射将变得无效。在这种情况下，需要进行TLB刷新以确保所有核心的TLB都具有最新的地址映射。

   需要注意的是，TLB刷新是由处理器硬件自动处理的，而不是由软件显式执行的。处理器会在需要时自动检测到页表的更改，并相应地刷新TLB，以确保正确的地址转换。因此，在这些场景中，操作系统或处理器会自动处理TLB刷新，开发人员通常无需显式地编写TLB刷新代码。

3. 外核中程序调用 libOS 提供的功能接口不需要tlb flush

   外核是一种软件层，提供了在操作系统内核和用户空间应用程序之间的抽象接口。它使应用程序能够通过libOS访问底层操作系统功能，而无需直接与底层操作系统交互。在这种情况下，外核和libOS通常会共享相同的虚拟地址空间。

   由于外核和libOS处于相同的虚拟地址空间中，TLB中的映射关系不会发生变化，因此在调用libOS提供的功能接口时，不需要执行TLB刷新操作。TLB仍然包含正确的地址映射，并且虚拟地址将被正确地转换为物理地址。

   需要注意的是，具体情况可能因不同的系统设计和实现而有所不同。某些特定的系统架构或实现可能需要进行TLB刷新操作，以确保正确的地址转换。因此，对于特定的外核和libOS组合，最好参考其文档或开发者指南，以了解是否需要执行TLB刷新操作

4. 为什么inode文件系统，并未在目录项中区分子文件和子目录，但是在FAT中，目录项中特意使用一位区分两者，为什么FAT这么设计

   FAT（File Allocation Table）是一种文件系统，常用于早期的DOS和Windows操作系统。相比于现代的inode文件系统，FAT文件系统设计的初衷是为了在资源有限的环境下提供简单而高效的文件管理。

   在FAT文件系统中，目录项的设计主要考虑了对存储空间的节约以及快速访问文件的需求。因此，FAT文件系统在目录项中使用一位来区分子文件和子目录，主要有以下原因：

   1. 存储空间节约：FAT文件系统早期用于磁盘驱动器较小的存储介质，如软盘。为了节约存储空间，FAT文件系统的目录项被设计为固定长度，每个目录项占用固定的字节大小。通过使用一位来区分子文件和子目录，可以在不增加目录项长度的情况下，区分文件和目录类型。
   2. 快速访问文件：FAT文件系统使用文件分配表（File Allocation Table）来管理磁盘上文件的分配情况。为了快速访问文件，FAT文件系统将文件和目录的目录项组织在磁盘上的连续区域。通过在目录项中明确区分子文件和子目录，可以根据目录项的类型快速定位到所需的文件或目录的位置。

   需要注意的是，FAT文件系统的设计权衡了存储空间和访问效率的考虑，并且它并不支持一些现代文件系统的高级特性，如文件权限、硬链接等。因此，在更现代的操作系统和应用中，通常采用inode文件系统，它提供了更丰富的功能和更灵活的文件管理方式。

5. Why could not a ticket lock scale to many-core system? 

   In ticket lock, all waiters are spinning on the same memory address. When the releaser wants to release the lock, it will modify the lock variable. This leads to a broadcast in cache coherence protocol to invalid all copies in other cores’ private cache. After the releaser modified the variable, it will be synced to all other cores’ private cache again. The cache coherence protocol will introduce overhead which grows linearly to the number of cores.

   在票务锁中，所有服务员都在同一个内存地址上旋转。当释放器想要释放锁时，它将修改锁变量。这导致缓存一致性协议中的广播使其他核心私有缓存中的所有副本无效。释放器修改变量后，它将再次同步到所有其他内核的私有缓存。缓存一致性协议将引入开销，开销会线性增长到内核数量。

6. How does MCS lock solve the scalability problem? (4') 

   In MCS lock, the waiter spins on its own variable. The lock variables are not shared so no frequent cache coherence operation will occur. When a releaser wants to release the lock, it only modifies the variable in the next waiter, so cache coherence protocol is only performed between two cores, whose overhead is not related to the number of cores.

   在MCS锁中，服务员在自己的变量上旋转。锁定变量不共享，因此不会发生频繁的缓存一致性操作。当释放器想要释放锁时，它只会修改下一个服务员中的变量，因此缓存一致性协议仅在两个内核之间执行，其开销与内核数量无关。

#### chapter14  

3. 在EL1或EL0模式下执行特权指令将触发虚拟机下陷，将控制权转移给虚拟机监控 器。在处理完虚拟机下陷之后，虚拟机监控器将控制权交还给虚拟机。以下是几种可 能触发虚拟机下陷的例子： 

   访问内存导致第二阶段页表的缺页异常。 

   使用wfi指令。

    在使用第二阶段页表时修改 TTBRO EL1寄存器的值。

   请判断它们是否会引起虚拟机下陷。如果是，请进一步回答在虚拟机恢复执行之后， 是否需要重新执行此条引起下陷的指令。 

- 访问内存导致第二阶段页表的缺页异常会引起虚拟机下陷，并且在虚拟机恢复执行后需要重新执行引起下陷的指令。
- 使用wfi指令会引起虚拟机下陷，但在虚拟机恢复执行后不需要重新执行使用wfi指令。
- 使用第二阶段页表时修改 TTBRO EL1寄存器的值会引起虚拟机下陷，并且在虚拟机恢复执行后需要重新执行修改 TTBRO EL1寄存器的指令

8. 假设有10个虚拟机，每个虚拟机有10个vCPU。总共有几个 QEMU进程？每个进程 中有多少个线程（假设为KVM/QEMU系统，忽略QEMU的 iothread）？ 

9. 使用KVM/ARM和QEMU运行一个 Linux虚拟机，并统计虚拟机在启动过程中发生 的虚拟机下陷次数
