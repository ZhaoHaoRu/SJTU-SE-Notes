# Splay Tree

## 特点

### 利用局部性

![Untitled](Splay%20Tree%201ce39881ef824fe49b7552de1afbb557/Untitled.png)

1. 将刚被访问的节点，及时地“转移”至树根（附近）
2. 伸展树无需时刻都严格地保持全树的平衡，但却能够在任何足够长的真实操作序列中，保持分摊意义上的高效率
3. 不需要对基本的二叉树节点结构，做任何附加的要求或改动，更不需要记录平衡因子或高度之类的额外信息，故适用范围更广

## 时间复杂度

| 插入 | 分摊的⁍时间内完成 |
| --- | --- |
| 删除 | 分摊的⁍时间内完成 |
| 查找 | 分摊的⁍时间内完成 |
| 伸展 | 分摊的⁍时间内完成， worst case: ⁍ |
- 最坏情况下的单次操作需要O(n)时间

## 调整策略：双层伸展

- 单层伸展的缺陷：效率取决于树的初始形态和节点的访问次序。对于很多访问序列，单次访问的分摊时间复杂度在极端情况下可能高达$Ω(N)$,对于规模为任意n的伸展树，只要按关键码单调的次序，周期性地反复进行查找，则无论总的访问次数m >> n有多大，就分摊意义而言，每次访问都将需要$Ω(N)$时间（解释：问题根源也可再进一步地解释为：在持续访问的过程中，树高依算术级数逐步 从n - 1递减至 [n/2]，然后再逐步递增回到n - 1)
- 具体操作：每次都从当前节点v向上追溯两层（而不是仅一层），并根据其父亲p以及祖父g的相对位置，进行相应的旋转。

![Untitled](Splay%20Tree%201ce39881ef824fe49b7552de1afbb557/Untitled%201.png)

![Untitled](Splay%20Tree%201ce39881ef824fe49b7552de1afbb557/Untitled%202.png)

在最后一次调整时，v的父亲p即是树根r：

![Untitled](Splay%20Tree%201ce39881ef824fe49b7552de1afbb557/Untitled%203.png)

- 双层伸展策略优于逐层伸展策略关键：zig-zig和zag-zag调整
- 双层伸展策略优于逐层伸展策略的原因：双层伸展策略可“智能”地“折叠”被访问的子树分支，从而有效地避免对长分支的连续访问。这就意味着，即便节点v的深度为$O(n)$，双层伸展策略既可将v推至树根，亦可令对应分支的长度以几何级数（大致折半）的速度收缩。
- 即便每次都“恶意地”试图访问最底层节点，最坏情况也不会持续发生。可见，伸展树虽不能杜绝最坏情况的发生，却能有效地控制最坏情况发生的频度，从而在分摊意义下保证整体的高效率。
- 算法：

![Untitled](Splay%20Tree%201ce39881ef824fe49b7552de1afbb557/Untitled%204.png)

![Untitled](Splay%20Tree%201ce39881ef824fe49b7552de1afbb557/Untitled%205.png)

![Untitled](Splay%20Tree%201ce39881ef824fe49b7552de1afbb557/Untitled%206.png)

## 查找

![Untitled](Splay%20Tree%201ce39881ef824fe49b7552de1afbb557/Untitled%207.png)

## 插入

以上接口Splay::search()已集成了splay()伸展功能，故查找返回后，树根节点要么等于查找目标（查找成功），要么就是_hot，而且恰为拟插入节点的直接前驱或直接后继（查找失败）。

- 关键码e插至伸展树T中，首先调用伸展树查找接口Splay::search(e)，查找该关键码（图(a)）。于是，其中最后被访问的节点t，将通过伸展被提升为树根，其左、右子树分别记作$T_L$和$T_R$（图(b)）。
- 接下来，根据e与t的大小关系（不妨排除二者相等的情况），以t为界将T分裂为两棵子树。比如，不失一般性地设e大于t。
- 于是，可切断t与其右孩子之间的联系（图(c)），再将以e为关键码的新节点v作为树根，并以t作为其左孩子，以$T_R$作为其右子树（图(d)）

![Untitled](Splay%20Tree%201ce39881ef824fe49b7552de1afbb557/Untitled%208.png)

- 算法实现：

![Untitled](Splay%20Tree%201ce39881ef824fe49b7552de1afbb557/Untitled%209.png)

## 删除

![Untitled](Splay%20Tree%201ce39881ef824fe49b7552de1afbb557/Untitled%2010.png)

- 首先亦调用接口Splay::search(e)，查找该关键码，且不妨设命中节点为v（图(a)）。于是，v将随即通过伸展被提升为树根，其左、右子树分别记作$T_L$和$T_R$（图(b)）
- 接下来，将v摘除（图(c)）。然后，在$T_R$中再次查找关键码e。尽管这一查找注定失败，却可以将TR中的最小节点m，伸展提升为该子树的根。
- 只需将$T_L$作为左子树与m相互联接，即可得到一棵完整的二叉搜索树（图(e)）。如此不仅删除了v，而且既然新树根m在原树中是v的直接后继，故数据局部性也得到了利用。
- 算法实现：

![Untitled](Splay%20Tree%201ce39881ef824fe49b7552de1afbb557/Untitled%2011.png)

## 综合评价

![Untitled](Splay%20Tree%201ce39881ef824fe49b7552de1afbb557/Untitled%2012.png)