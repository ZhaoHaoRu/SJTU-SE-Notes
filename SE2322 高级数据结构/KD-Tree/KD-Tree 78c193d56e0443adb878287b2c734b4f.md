# KD-Tree

## 引例：范围查询

### 1.一维内的查询

- $*O(nlogn)*$时间内，将点集P组织为一个有序向量，不大于查询区间的最大点pt的定位需要$*O(logn)*$时间。若接下来的遍历总共报告出r个点，则总体的查询时间成本为$*O(r + logn)*$
- 转化为二叉平衡搜索树：
    - 查找的过程中，在每一节点处，至多只需做一次（而不是两次）关键码的比较。当然另一方面，无论成功与否，每次查找因此都必 然终止于叶节点，不小于目标关键码的最小叶节点。
    - 
    
    ![Untitled](KD-Tree%2078c193d56e0443adb878287b2c734b4f/Untitled.png)
    
    - 查询算法：找到最低共同祖先（lowest common ancestor, LCA），设查询区间为[1, 23]，从这一共同祖先节点出发，分别重走一遍通往节点3和24的路径（分别记作path(3)path(24)）。在沿着path(3)/path(24)下行的过程中，忽略所有的右转/左转；而对于每一次左转/右转，都需要遍历对应的右子树/左子树（图中以阴影示意），并将其中的叶节点悉数报告出来。
    
    ![Untitled](KD-Tree%2078c193d56e0443adb878287b2c734b4f/Untitled%201.png)
    
    - 时间复杂度：建树为$O (nlogn)$，每次查询都可在$*O(r + logn)*$时间内完成，对于输出规模敏感
    - 优点：便捷地推广至二维甚至更高维。

## 构造

- 每个矩形区域的左边和底边开放，右边和顶边封闭。
- 流程：
    - P为输入点集与树中当前节点所对应矩形区域的交集（即落在其中的所有点），则可递归地将该矩形区域切分为两个子矩形区域，且各包含P中的一半点。
    - 若当前节点深度为偶（奇）数，则沿垂直（水平）方向切分，所得子区域随同包含的输入点分别构成左、右孩子。如此不断，直至子区域仅含单个输入点。每次切分都在中位点（median point）按对应的坐标排序居中者处进行，以保证全树高度不超过$*O(logn)*$。
- 算法实现：

![Untitled](KD-Tree%2078c193d56e0443adb878287b2c734b4f/Untitled%202.png)

- 图解

![Untitled](KD-Tree%2078c193d56e0443adb878287b2c734b4f/Untitled%203.png)

## 范围查询

任一矩形查询区域R，范围查询的过程均从树根节点出发，按如下方式递归进行。

- 情况A：若矩形区域v完全包含于R内，则其中所有的输入点亦均落在R内，于是只需遍历一趟子树v，即可报告这部分输入点。
- 情况B：若二者相交，则有必要分别深入到v的左、右子树中，继续递归地查询。
- 情况C：若二者彼此分离，则子集v中的输入点绝不可能落在R内，故对应的递归分支至此即可终止。

算法：

![Untitled](KD-Tree%2078c193d56e0443adb878287b2c734b4f/Untitled%204.png)

被报告的子树总共不超过$*O(\sqrt{n})*$棵，累计耗时$O(\sqrt{n})$

## KD-Tree 效率

<img src="assets/image-20230505203950353.png" alt="image-20230505203950353" style="zoom:50%;" />

## exercise Tips

- 查询时间复杂度的证明：

![Untitled](KD-Tree%2078c193d56e0443adb878287b2c734b4f/Untitled%205.png)

![Untitled](KD-Tree%2078c193d56e0443adb878287b2c734b4f/Untitled%206.png)

![Untitled](KD-Tree%2078c193d56e0443adb878287b2c734b4f/Untitled%207.png)

- 查询某一维的最小值

![Untitled](KD-Tree%2078c193d56e0443adb878287b2c734b4f/Untitled%208.png)

- 查找最相近点
    - 算法流程
    1. 在KD树中找出包含目标点 t 的叶结点。即从根结点出发，递归地向下搜索二叉树。若在当前划分维度, t 的坐标值小于切分点，则移动到左子结点，否则移动到右子结点，直到走到叶结点为止。
    2. 以此叶结点为“当前最近点”，递归的向上回溯，在每个结点进行以下操作：
       
        i) 如果该结点保存的实例点比当前最近点距离目标点更近，则更新“当前最近点”，也就是说以该实例点为“当前最近点”。
        
        ii)当前最近点一定存在于该结点一个子结点对应的区域，检查子结点的父结点的另一子结点对应的区域是否有更近的点。具体做法是，检查另一子结点对应的区域是否以「目标点为球心，以目标点与“当前最近点” 间的距离为半径的超球体」相交。
        
        a) 如果相交，可能在另一个子结点对应的区域内存在距目标点更近的点，移动到另一个子结点，接着，继续递归地进行最近邻搜索；
        
        b) 如果不相交，向上回溯。
        
    
    当回退到根结点时，搜索结束，最后的“当前最近点”即为x 的最近邻点。
    
    - example：
    
    ![Untitled](KD-Tree%2078c193d56e0443adb878287b2c734b4f/Untitled%209.png)
    
    ![Untitled](KD-Tree%2078c193d56e0443adb878287b2c734b4f/Untitled%2010.png)
    
    ![Untitled](KD-Tree%2078c193d56e0443adb878287b2c734b4f/Untitled%2011.png)
    
    - 代码实现