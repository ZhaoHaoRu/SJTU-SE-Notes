# B-Tree

## 适用背景

分级存储，对外存进行批量式访问，通过时间成本相对极低的多次内存操作，来替代时间成本相对极高的单次外存操作。

## 多路平衡搜索树

m阶B-树（B-tree），即m路平衡搜索树（m ≤ 2）

特点：

- 所有外部节点均深度相等
- 每个内部节点都存有不超过m - 1个关键码，以及用以指示对应分支的不超过m个引用
- 各内部节点的分支数也不能太少。具体地，除根以外的所有内部节点，都应满足： $n + 1$ $≥$$\lceil$$m/2$ $\rceil$
- 非空的B-树中，根节点应满足： n + 1 ≥ 2
- 注意是分支数！！
    
    ![Untitled](B-Tree%201eb2d49f4f42475f94f44af54b66c541/Untitled.png)
    
- B-树的外部节点（external node）更加名副其实,它们实际上未必意味着查找失败，而可能表示目标关键码存在于更低层次的某一外部存储系统中。在计算B-树高度时，还需要计入其最底层的外部节点。
- example：

![Untitled](B-Tree%201eb2d49f4f42475f94f44af54b66c541/Untitled%201.png)

![Untitled](B-Tree%201eb2d49f4f42475f94f44af54b66c541/Untitled%202.png)

![Untitled](B-Tree%201eb2d49f4f42475f94f44af54b66c541/Untitled%203.png)

## 时间复杂度

| 查找 | ⁍ |
| --- | --- |
| 插入 | ⁍ |
| 删除 | ⁍ |

## 查找

- 从根节点开始，通过关键码的比较不断深入至下一层，直到某一关键码命中（查找成功），或者到达某一外部节点（查找失败）。
- 只有在切换和更新当前节点时才会发生I/O操作，而在同一节点内部的查找则完全在内存中进行。
- 在节点内部直接使用顺序查找策略，而不必采用二分查找之类的复杂策略。
- 对于活跃的B-树，其根节点会常驻于内存；此外，任何时刻通常只有另一节点（称作当前节点）留驻于内存
- 时间复杂度证明：

![Untitled](B-Tree%201eb2d49f4f42475f94f44af54b66c541/Untitled%204.png)

![Untitled](B-Tree%201eb2d49f4f42475f94f44af54b66c541/Untitled%205.png)

- 算法实现：

![Untitled](B-Tree%201eb2d49f4f42475f94f44af54b66c541/Untitled%206.png)

## 插入

- 查找到对应的叶节点，在该节点中负责插入
- 该节点内关键码的总数依然合法（即不超过m - 1个），则插入操作随即完成。否则，称该节点发生了一次上溢（overflow）
- 上溢处理步骤：
    - 
    
    ![Untitled](B-Tree%201eb2d49f4f42475f94f44af54b66c541/Untitled%207.png)
    
    - 尽管上溢节点的父节点存在，但业已处于饱和状态。此时如图(b2)，在强行将被提升的关键码插入父节点之后，尽管上溢节点也可得到修复，却会导致其父节点继而发生上溢，这种现象称作上溢的向上传递。好在每经过一次这样的修复，上溢节点的高度都必然上升一层。这意味着上溢的传递不至于没有尽头，最远不至超过树根。
    - 上溢果真传递至根节点，则可令被提升的关键码（37）自成一个节点，并作为新的树根。
    - 整个过程中所做分裂操作的次数，必不超过全树的高度，即$*O(log_mN)*$
    - 
    
    ![Untitled](B-Tree%201eb2d49f4f42475f94f44af54b66c541/Untitled%208.png)
    
- 算法实现：（貌似并不重要）

![Untitled](B-Tree%201eb2d49f4f42475f94f44af54b66c541/Untitled%209.png)

![Untitled](B-Tree%201eb2d49f4f42475f94f44af54b66c541/Untitled%2010.png)

![Untitled](B-Tree%201eb2d49f4f42475f94f44af54b66c541/Untitled%2011.png)

- 单次插入操作平均引发的分裂次数，远远低于这一估计（$*O(log_mN)*$），故时间通常主要消耗于对目标关键码的查找。

## 删除

- 首先需要调用search(e)查找e所属的节点。倘若查找失败，则说明关键码e尚不存在，删除操作即告完成.
- 否则目标关键码所在的节点必由返回的位置v指示。此时，通过顺序查找，即可进一步确定e在节点v中的秩r。
- 若节点v非叶节点，e的直接后继关键码所属的节点u必为叶节点，且该关键码就是其中的最小者u[0]。既然如此，只要令e与u[0]互换位置，即可确保待删除的关键码e所属的节点v是叶节点。
- 直接将e（及其左侧的外部空节点）从v中删去。
- 此时，若该节点所含关键码的总数依然合法（即不少于$\lceil$$m/2$ $\rceil$ - 1），则删除操作随即完成。
否则，称该节点发生了下溢（underflow）
- 下溢处理：

![Untitled](B-Tree%201eb2d49f4f42475f94f44af54b66c541/Untitled%2012.png)

![Untitled](B-Tree%201eb2d49f4f42475f94f44af54b66c541/Untitled%2013.png)

![Untitled](B-Tree%201eb2d49f4f42475f94f44af54b66c541/Untitled%2014.png)

- 接下来，还须检查父节点P，关键码y的删除可能致使该节点出现下溢。好在，即便如此，也尽可套用上述三种方法继续修复节点P。当然，修复之后仍可能导致祖父节点以及更高层节点的下溢，这种现象称作下溢的传递。特别地，当下溢传递至根节点且其中不再含有任何关键码时，即可将其删除并代之以其唯一的孩子节点，全树高度也随之下降一层。
- 整个下溢修复的过程中至多需做$O(log_mN)$次节点合并操作，因某一关键码的删除而导致$O(log_mN)$次合并操作的情况也极为罕见，单次删除操作过程中平均只需做常数次节点的合并。
- 算法实现：（不重要）

![Untitled](B-Tree%201eb2d49f4f42475f94f44af54b66c541/Untitled%2015.png)

![Untitled](B-Tree%201eb2d49f4f42475f94f44af54b66c541/Untitled%2016.png)

![Untitled](B-Tree%201eb2d49f4f42475f94f44af54b66c541/Untitled%2017.png)

![Untitled](B-Tree%201eb2d49f4f42475f94f44af54b66c541/Untitled%2018.png)

![Untitled](B-Tree%201eb2d49f4f42475f94f44af54b66c541/Untitled%2019.png)

### 用途

**用在磁盘文件组织、数据索引和数据库索引（MySQL等）**

## exercise Tips:

![Untitled](B-Tree%201eb2d49f4f42475f94f44af54b66c541/Untitled%2020.png)

![Untitled](B-Tree%201eb2d49f4f42475f94f44af54b66c541/Untitled%2021.png)

![Untitled](B-Tree%201eb2d49f4f42475f94f44af54b66c541/Untitled%2022.png)

![Untitled](B-Tree%201eb2d49f4f42475f94f44af54b66c541/Untitled%2023.png)