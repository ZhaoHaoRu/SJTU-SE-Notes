# 软件工程

![Untitled](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%20ca8bc2ceb7d54b54bd3def31a7d6fd3d/Untitled.png)

- 橘色会考大题
- 

![Untitled](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%20ca8bc2ceb7d54b54bd3def31a7d6fd3d/Untitled%201.png)

## 软件工程引论

![Untitled](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%20ca8bc2ceb7d54b54bd3def31a7d6fd3d/Untitled%202.png)

- ****什么是软件****
- ****软件特征****
- ****软件面临的新挑战****
- ****软件危机的主要表现****
- ****当前软件实践的问题****
- ****软件危机和问题的根源****
- ****什么是有价值的软件****
- ****软件工程的经典定义****
- ****软件工程知识体系SWEBOK V3的15个知识域****
- ****软件工程技术****
    - 系统工程
    - 需求
    - 设计
    - 编程
    - 测试
    - 部署
    - 运行和维护
- ****控制软件开发的复杂性****
- ****软件建模是软件工程的核心技术****
- ****模型、模型的功能、建模的重要性****
    - 有用模型的特征
    - 
    
    ![Untitled](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%20ca8bc2ceb7d54b54bd3def31a7d6fd3d/Untitled%203.png)
    
- ****软件建模的方法****
    - ****形式化方法****
    - ****结构化方法****
    - ****面向对象方法****
        - ****UML模型****
    - ****基于构件****
    - ****面向服务****
    - ……
    

## 软件过程

![Untitled](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%20ca8bc2ceb7d54b54bd3def31a7d6fd3d/Untitled%204.png)

- ****软件工程的金三角****
- ****什么是软件过程****
- ****软件过程的组成****
- ****软件生存周期模型****
    - ****瀑布(Waterfall)模型****
        - ****特点****
        - ****价值和风险****
    - ****增量（Incremental）模型****
        - ****风险和适用时机****
    - ****演化(Evolutionary)模型****
        - **特点（**与增量模型的区别是：需求在开发早期不能被完全了解和确定，在一部分被定义后开发就开始了，然后在每个相继的版本中逐步完善）
        - ****演化模型举例****
        - ****演化模型价值：降低风险****
        - ****演化模型已成为主流****
    - ****快速原型模型 Rapid Prototyping Model****
    - **螺旋模型 Spiral Model**
- ****统一软件过程 RUP****
    - ****RUP的四个阶段****
        - ****阶段和迭代****
        - ****一个迭代周期：一个小的瀑布模型****
- ****敏捷过程****
    - ****敏捷宣言****
    - ****敏捷过程的适用范围****
- ****Scrum －敏捷的软件项目管理****
    - ****Scrum的核心准则****
    - ****Scrum过程框架****
    - ****Scrum Players****
    - ****Sprint 任务板****

## 需求工程

![Untitled](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%20ca8bc2ceb7d54b54bd3def31a7d6fd3d/Untitled%205.png)

- **软件需求的定义**
- ****FURPS****
    - ****定义 Functionality 需求****
    - ****定义 Usability 需求****
    - ****定义 Reliability 需求****
    - ****定义 Performance 需求****
    - ****定义 Supportability 需求****
    - ****FURPS +****
        - ****设计约束****
    - ****软件需求的三个层次****
    - ****需求驱动开发****
    - ****优秀需求具有的特性****
        - ****无二义性****
            - ****二义性与可理解性的关系？****
        - ****可验证性****
- ****需求工程****
    - **需求获取**
    - ****前景文档（Vision）****
    - 
        - ****分析问题及根源****
            - ****识别业务解决方案****
        - ****识别项目干系人****
        - ****识别项目的约束****
        - ****获取常用术语****
        - ****识别需求的来源****
        - ****收集需求****
            - 如何获得需求
            - 项目干系人需求的收集技术
        - ****产品定位****
        - ****撰写产品特性****
        - ****定义质量范围****
        - ****定义文档需求****
        - ****建立项目范围****
        - ****划分特性优先级****
    - **需求分析**
        - ****分析建模准则****
        - ****分析模型****
    - **需求定义和验证**
        - ****需求定义的任务****
        - ****成果：软件需求规约****
            - ****细化需求****
            - ****设计用户界面和接口（如何描述用户界面）****
            - ****SRS模板****
            - ****需求验证****
            - ****需求评审方法****
            - ****需求评审的输入和输出****
    - ****需求管理****
        - ****建立需求基线****
        - ****需求变更控制****
        - ****需求跟踪****

## 面向对象设计

![Untitled](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%20ca8bc2ceb7d54b54bd3def31a7d6fd3d/Untitled%206.png)

- 面向对象方法概述
    - ****Object Technology的定义和strength****
    - ****The History of Object Technology****
    - ****UML （Unified Modeling Language)****
    - ****Where Is Object Technology Used?****
    - ****面向对象方法的四个步骤****
- **面向对象的基本概念**
    - ****What Is an Object?——Formal Definition****
    - ****Representing Objects in the UML****
    - ****Basic Principles of Object Orientation****
        - ****What Is Abstraction?****
        - ****What Is Encapsulation?****
        - ****What Is Modularity?****
        - ****What Is Hierarchy?****
        - ****What Is a Class?****
            - ****Representing Classes in the UML****
            - ****The Relationship between Classes and Objects****
        - ****What Is a Package?****
- ****面向对象分析的步骤****
    - **用例建模**
        - ****Use Case技术****
        - ****Use-Case 模型的组成****
        - ****Actor 和 Use Case****
        - ****如何识别Actor****
        - ****如何识别Use Case****
        - ****避免功能分解——一个用例定义了和actor之间的一次完整对话。****
        - ****通信-关联 Communicates-Association****
        - ****Use-Case Specifications****
            - ****事件流（基本流和备选流）****
            - ****Scenario 是Use-Case 的实例****
            - ****细化基本事件流****
            - ****细化通用备选流****
            - ****细化特殊备选流****
        - ****What Is an Activity Diagram?****
        - ****Partitions****
        - ****前置条件****
        - ****后置条件****
        - ****其它Use Case属性****
        - ****Use Case间的关系****
            - Include 包含
            - Extend 扩展
            - Generalization 泛化
            - ****什么是Actor Generalization****
    - 建立概念模型
        - ****概念类图的作用****
        - ****Identify Conceptual Class（****Strategies to Identify Conceptual Classes）
            - ****Use a conceptual class category list****
            - ****Finding conceptual classes with Noun Phrase****
            - ****A Common Mistake in Identifying Conceptual Classes：represent something as an attribute when it should have been a concept，****If we do not think of some conceptual class X as a number or text in the real world,X is probably a conceptual class, not an attribute.
        - **Conceptual Class之间的关系**
            - ****Relationships: Association(Aggregation represents a “part-of” relationship)****
                - ****What Is Multiplicity?（多重度）****
                - ****Multiplicity Indicators****
                - ****What Are Roles?****
                - ****What Is Navigability?****
                - ****两个类之间关联同时可以有多条****
                - ****What Is an Aggregation?****
                - ****What Is Composition？（部分离开整体不能生存）****
            - ****Relationships: Generalization（a kind of)****
                - ****Single Inheritance****
                - ****Multiple Inheritance****
                - ****What Is Inherited?****
                - ****Liskov替换原则 ㇐㇐ LSP****
            - ****Relationships: Dependency****
                - ****Local Variable Visibility****
                - ****Parameter Visibility****
                - ****Global Visibility****
        - ****State Machine Diagrams****
            - ****Special States:The initial state, A final state****
            - ****Activities and Actions****
    - 用例分析
        - ****三种Analysis Class****
            - ****What Is an Entity Class****
                - ****The Role of an Entity Class****
            - ****What Is a Boundary Class****
                - ****The Role of a Boundary Class****
            - ****What Is a Control Clas****
                - ****The Role of a Control Class****
            - ****What is an Interaction Diagram****
                - ****Create Sequence Diagrams(The Anatomy of Sequence Diagrams)****
                - ****Generate Communication Diagrams(The Anatomy of Communication Diagrams)****
            - **对照通信图建立类图，完善每个分析类的属性和操作**
            

## 设计工程

![Untitled](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%20ca8bc2ceb7d54b54bd3def31a7d6fd3d/Untitled%207.png)

- **软件设计的原则**
    - ****抽象 abstraction（好处，主要抽象手段）****
    - ****分解和模块化****
    - ****软件模块化的好处****
    - ****软件模块****
    - ****分解 decomposition****
    - ****模块化的成本****
    - ****信息隐藏 Information Hiding****
    - ****模块独立****
    - ****模块独立的衡量指标（高内聚和低耦合）****
        - ****内聚的类型****
        - ****低、中、高内聚****
        - ****耦合的类型****
- **软件设计的步骤和方法**
    - ****设计的步骤****
    - ****架构设计****
    - ****软件设计的质量要求****
    - ****7种软件设计的坏味道****
    - ****设计臭味导致的问题****
    - ****如何进行高质量的设计——模式(Pattern)的复用****
    - ****软件设计的模式（及分类）****
    - ****架构风格举例：MVC****
    - ****设计模式举例：Facade模式****
- ****软件架构设计****
    - 架构设计的内容和目标
    - ****① 设计软件架构的多个视图****
        - ****部署视图（物理视图）****
            - ****部署架构风格****
            - ****Client/Server Architectures****
            - ****Serverless Architecture****
            - ****P2P Architecture****
        - ****逻辑视图****
            - ****逻辑架构风格****
                - ****1) 层次架构（layered architecture）风格****
                - ****中间件****
                - ****中间件的分类****
                - ****2) MVC****
                - ****3) 3 Tiers****
                - ****4) 管道和过滤器（Pipes and Filters）****
                - ****5）服务与微服务的架构风格****
                    - ****微服务架构风格****
                    - ****容器****
                - ****6) 仓库风格****
                - ****7) 微内核风格****
                - ****8) 开环和闭环控制风格****
        - ****进程视图****
            - ****多进程/线程间的协作****
            - ****死锁的预防、检测和解除****
        - ****实现视图****
            - ****构件图Component Diagram****
            - ****构件图的主要组成****
        - ****How many views?（实际应用中需要多少视图）****
        - ****技术视图 Technical view****
            - ****框架(Framework)****
            - ****框架举例****
        - ****数据视图 Data View****
        - ****页面视图 Page view****
        - ****安全视图 Security view****
            - ****权限控制****
    - ****选择软件质量属性的设计战术****
        - **易用性**
        - ****可靠性****
        - ****性能****
        - ****可测试性与可维护性****
        - ****多目标权衡****
        

## 面向对象设计

![Untitled](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%20ca8bc2ceb7d54b54bd3def31a7d6fd3d/Untitled%208.png)

- ****Analysis Versus Design（Analysis 和design的区别）****
- ****面向对象设计Object Oriented Design****
    - ****细化示例：细化UI类****
    - ****优化示例：优化Entity类****
    - ****优化示例：优化Control类****
    - ****优化示例：Partitioning****
    - ****优化示例：无环依赖****
- ****From Design to Implementation****
    - ****Forward Engineering****
    - ****Reverse Engineering****
    - ****Round-Trip Engineering****
- **面向对象设计的原则**
    - **单一职责原则SRP: The Single – Responsibility Principle**
    - ****里氏替换原则LSP: The Liskov Substitution Principle****
    - ****依赖倒置原则DIP: The Dependency Inversion Principle****
    - **接口隔离原则ISP: The Interface Segregation Principle**
    - **开-闭原则OCP: The Open-Closed Principle**
    - ****组合/聚合复用原则CARP: The Composite/Aggregate Reuse Principle****
        - ****继承复用(优缺点）****
        - ****组合/聚合复用（优缺点）****
        - ****Coad法则****
        - ****CARP原则小结****
    - ****Summary:设计原则****
- **GoF 设计模式**
    - ****Design Patterns Categories****
    - ****Creational Patterns（创建型模式）****
        - ****1）工厂方法 Factory Method****
            - ****Factory Method模式解决的问题****
            - ****Factory Method模式的优点****
            - ****Factory Method模式的缺点****
            - ****适用场景****
        - ****2）抽象工厂 Abstract Factory****
            - ****Abstract Factory模式解决的问题****
            - ****Abstract Factory模式的优缺点****
            - ****适用场景****
        - ****3） 建造者模式 Builder****
            - ****Builder模式的类图****
            - ****Builder模式的优点****
            - ****Builder模式的缺点****
            - ****适用场景****
        - ****4）原型模式 Prototype****
            - ·****浅克隆和深克隆****
            - **Intent**
            - **Motivation**
            - ****Prototype模式的优点****
            - ****Prototype模式的缺点****
            - ****Prototype模式的适用性****
        - ****5）单例模式 Singleton****
            - ****Singleton的设计方案****
            - ****单例模式的优点****
            - ****单例模式的缺点****
            - ****适用场景0****
        - ****Summary：Creational Patterns（目的）****
    - ****Structural Patterns（结构型模式）****
        - ****6）适配器模式Adapter****
            - ****Adapter模式的Solution****
                - 类Adapter
                - 对象Adapter
            - ****适用场景****
        - ****7）桥接模式Bridge****
            - ****适用场景****
        - ****8）组合模式Composite****
            - ****Composite模式的结构****
            - ****组合模式的实现方法****
            - ****Composite模式的优缺点****
            - ****适用场景****
        - ****9）装饰器模式Decorator****
            - ****Decorator模式的优点****
            - ****Decorator模式的缺点****
            - ****适用场景****
        - ****10）门面模式Façade****
            - ****适用场景****
        - ****11）代理模式Proxy****
            - ****常见的代理类型****
            - ****Proxy模式的优点****
            - ****Proxy模式的缺点****
            - ****适用场景****
        - ****12）享元模式Flyweight****
            - ****采用单纯享元模式****
            - ****采用复合享元模式****
            - ****Flyweight模式的structure****
            - ****适用场景****
        - ****Summary：Structural Patterns****
    - ****Behavioral Patterns（行为型模式）****
        - ****13）解释器模式Interpreter****
            - ****适用场景****
            - ****Interpreter模式的结构****
        - ****14）模板方法模式Template Method****
            - ****Template Method模式解决的问题****
            - ****模式中的方法****
            - ****实际应用****
        - ****15) 责任链模式Chain of Responsibility****
            - ****责任链模式的结构****
            - ****纯的与不纯的责任链模式****
            - ****适用场景****
        - ****16 ）命令模式Command****
            - ****命令模式的结构****
        - ****17）迭代器模式Iterator****
            - ****迭代器模式解决的问题****
            - ****迭代器模式的结构****
            - ****模式分析：应用了工厂方法模式****
            - ****列表迭代器****
            - ****多态迭代器Polymorphic Iterator****
            - ****其它考虑（主动(Active)迭代器 vs. 被动(Passive)迭代器、静态迭代器vs. 动态迭代器）****
        - ****18）策略模式Strategy****
            - ****模式分析****
            - 用configuration进行配置
            - ****适用场景****
        - ****19）中介者模式Mediator****
            - ****中介者模式的结构****
            - ****中介者模式的实现要点****
            - ****适用场景****
        - ****20）观察者模式Observer****
            - ****观察者模式的结构****
        - ****21）备忘录模式Memento****
            - ****备忘录模式的结构****
        - ****22）状态模式State****
            - ****实现要点****
            - ****Strategy模式与State模式的区别****
        - ****23）访问者模式Visitor****
            - ****使用visitor的compiler例子****
            - ****访问者模式的结构****
        - ****Summary: Behavioral Patterns****
        - ****设计模式是“封装变化”方法的最佳阐释****
        - ****设计模式间的关系****
        

## 用户界面设计

![Untitled](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%20ca8bc2ceb7d54b54bd3def31a7d6fd3d/Untitled%209.png)

- ****软件界面设计的综合考虑****
- ****界面设计中典型错误****
- ****界面设计的原则****
    - ****黄金规则****
        - ****从用户的角度去思考****
        - ****替用户着想 – 越用越好用****
- ****人机交互方式****
    - ****常见的人机交互方式****
        - ****新的人机交互方式－－可穿戴技术****
        - ****新的人机交互方式－－可植入设备****
- ****用户界面设计过程****
    - ****根据用户的特点设计人机界面****
- **界面设计的要素**
    - ****1）系统响应时间 （ Response time ）****
    - ****2）帮助设施（ Help facilities ）****
    - ****3）出错处理（ Error handling ）****
    - ****防错处理****
    - ****4）菜单和命令交互（ Menu and command Interaction）****
    - ****5) 可访问性****
    - ****6）国际化（Internationalization）****
    - ****7）合理的布局和合理的色彩****
    - ****8）移动界面设计的问题****
    - ****创新－－利用移动设备的感知设计****
    

## **编码和版本管理**

![Untitled](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%20ca8bc2ceb7d54b54bd3def31a7d6fd3d/Untitled%2010.png)

- **编码**
    - ****编码的目的和质量要求****
    - ****计算机上语言的层次****
    - ****高级程序设计语言的分类****
    - ****语言的选择****
    - ****语言选择举例****
    - ****编码准则****
- ****编码规范和代码评审****
    - ****编码的风格****
    - ****源程序的文档化 （code documentation）****
    - ****编码规范****
    - ****代码评审(code review)****
- ****代码自动生成****
    - ****从模型中生成代码****
    - ****确保模型和代码的一致****
    - ****其他的代码自动生成技术****
- ****软件版本管理****
    - ****软件配置项****
    - ****版本 version****
    - ****基线 baseline****
    - ****版本控制****
    - ****配置库CM Repository****
    - ****版本控制工具****
    - ****本地版本控制系统****
    - ****集中化的版本控制系统****
    - ****分布式版本控制系统****
- ****软件持续集成****
  
    

## **软件测试**

![Untitled](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%20ca8bc2ceb7d54b54bd3def31a7d6fd3d/Untitled%2011.png)

- ****测试（testing）的目的****
- ****有关软件测试的错误观点****
- ****测试准则****
- ****软件测试技术****
    - ****白盒测试****
        - ****控制流测试（属白盒测试）****
            - ****1）语句覆盖法****
            - ****2）判定覆盖（分支）****
            - ****3）条件覆盖****
            - ****4）判定/条件覆盖****
            - ****5）条件组合覆盖****
            - ****6）路径覆盖****
                - ****基本路径测试****
    - ****黑盒测试****
        - ****1）边界值划分(boundary value analysis)****
        - ****2）等价类划分(equivalence partitioning)****
        - ****3）错误推测法(error guessing)****
        - ****4）因果图法（Cause - Effect Graphics）****
        - ****综合运用多种黑盒测试用例设计策略****
- ****测试策略****
    - ****测试层次****
        - ****单元测试****
            - ****测什么****
            - ****何时测试和由谁测****
            - ****自动化的单元测试****
            - ****Junit 5 框架****
            - ****Junit Jupiter****
                - ****JUnit Repeating Tests****
                - ****JUnit 参数化测试****
                - ……
            - ****单元测试经验****
        - ****集成测试****
            - ****软件集成策略****
            - ****何时测试和由谁测****
        - ****系统测试****
    - **软件质量属性**
        - ****功能性测试****
        - ****可靠性测试****
        - ****性能测试****
        - ****易用性测试****
        - ****可移植性测试****
        - ****可维护性测试****
    - **其他测试策略**
        - ****验收测试****
        - ****α测试和β测试****
        - ****安装测试****
        - ****回归测试（regression testing）****
        - ****AB测试****
        - ****众测****
    - ****测试过程****
        - ****1）测试计划****
            - ****开始测试的标准****
        - ****2）测试设计****
        - ****3）测试开发****
        - ****4）测试执行****
            - ****缺陷报告****
            - ****缺陷跟踪系统****
        - ****5）测试评估****
            - ****终止测试的标准****
            - ****测试度量****
            - ****测试报告****
            - ****主要测试度量指标****
            - ****测试的文档****
            - ****测试的数据流****
    - ****自动化测试****
        - **工具类型**
        - **工具产品**
        - ****什么情况下适合用自动测试****
        - ****什么情况下不适合用自动测试****
        - ****自动化测试的误区****
    

## **软件运维**

![Untitled](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%20ca8bc2ceb7d54b54bd3def31a7d6fd3d/Untitled%2012.png)

- ****软件维护 “冰山”****
    - 挑战
- ****维护类型****
- ****维护的技术问题****
- ****维护成本****
- ****影响维护成本的因素****
- ****维护过程****
    - ****维护活动****
- ****软件维护技术****
    - ****程序理解****
    - ****逆向工程****
    - ****再工程****
- ****DevOps****
    - ****DevOps过程****
    - ****DevOps工具集****
    - ****云原生架构****
    - ****康威定律（Conway's Law）****